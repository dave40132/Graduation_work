/*
 * Copyright 1999-2004 Carnegie Mellon University.  
 * Portions Copyright 2002-2004 Sun Microsystems, Inc.  
 * Portions Copyright 2002-2004 Mitsubishi Electric Research Laboratories.
 * All Rights Reserved.  Use is subject to license terms.
 * 
 * See the file "license.terms" for information on usage and
 * redistribution of this file, and for a DISCLAIMER OF ALL 
 * WARRANTIES.
 *
 */
package cclo;

import edu.cmu.sphinx.frontend.BaseDataProcessor;
import edu.cmu.sphinx.frontend.Data;
import edu.cmu.sphinx.frontend.DataProcessingException;
import edu.cmu.sphinx.frontend.DoubleData;
import edu.cmu.sphinx.util.Complex;
import edu.cmu.sphinx.util.props.*;
import java.awt.BorderLayout;
import java.awt.Canvas;
import java.awt.Color;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.*;
import javax.swing.JOptionPane;
import javax.swing.Timer;
//import net.sf.json.JSONArray;
//import net.sf.json.JSONObject;

/**
 * Computes the Discrete Fourier Transform (FT) of an input sequence, using Fast
 * Fourier Transform (FFT). Fourier Transform is the process of analyzing a
 * signal into its frequency components. In speech, rather than analyzing the
 * signal over its entire duration, we analyze one <b>window</b> of audio data.
 * This window is the product of applying a sliding Hamming window to the
 * signal. Moreover, since the amplitude is a lot more important than the phase
 * for speech recognition, this class returns the power spectrum of that window
 * of data instead of the complex spectrum. Each value in the returned spectrum
 * represents the strength of that particular frequency for that window of data.
 * <p/>
 * By default, the number of FFT points is the closest power of 2 that is equal
 * to or larger than the number of samples in the incoming window of data. The
 * FFT points can also be set by the user with the property defined by {@link
 * #PROP_NUMBER_FFT_POINTS}. The length of the returned power spectrum is the
 * number of FFT points, divided by 2, plus 1. Since the input signal is real,
 * the FFT is symmetric, and the information contained in the whole vector is
 * already present in its first half.
 * <p/>
 * Note that each call to {@link #getData() getData} only returns the spectrum
 * of one window of data. To display the spectrogram of the entire original
 * audio, one has to collect all the spectra from all the windows generated from
 * the original data. A spectrogram is a two dimensional representation of three
 * dimensional information. The horizontal axis represents time. The vertical
 * axis represents the frequency. If we slice the spectrogram at a given time,
 * we get the spectrum computed as the short term Fourier transform of the
 * signal windowed around that time stamp. The intensity of the spectrum for
 * each time frame is given by the color in the graph, or by the darkness in a
 * gray scale plot. The spectrogram can be thought of as a view from the top of
 * a surface generated by concatenating the spectral vectors obtained from the
 * windowed signal.
 * <p/>
 * For example, Figure 1 below shows the audio signal of the utterance "one
 * three nine oh", and Figure 2 shows its spectrogram, produced by putting
 * together all the spectra returned by this FFT. Frequency is on the vertical
 * axis, and time is on the horizontal axis. The darkness of the shade
 * represents the strength of that frequency at that point in time:
 * <p>
 * <br><img
 * src="doc-files/139o.jpg"> <br><b>Figure 1: The audio signal of the utterance
 * "one three nine oh".</b>
 * <p>
 * <br><img src="doc-files/139ospectrum.jpg">
 * <br><b>Figure 2: The spectrogram of the utterance "one three nine oh" in
 * Figure 1.</b>
 */
public class DiscreteFourierTransform extends BaseDataProcessor implements Share {

    final int FFTNo = 1024;
    static int ratio = 0;
    /**
     * The property for the number of points in the Fourier Transform.
     */
    @S4Integer(defaultValue = -1)
    public static final String PROP_NUMBER_FFT_POINTS = "numberFftPoints";
    /**
     * The property for the invert transform.
     */
    @S4Boolean(defaultValue = false)
    public static final String PROP_INVERT = "invert";
    private boolean isNumberFftPointsSet;
    private int numberFftPoints;
    private int logBase2NumberFftPoints;
    private int numberDataPoints;
    private boolean invert;
    private Complex[] weightFft;
    private Complex[] inputFrame;
    private Complex[] from;
    private Complex[] to;
    private Complex weightFftTimesFrom2;
    private Complex tempComplex;

    public DiscreteFourierTransform(int numberFftPoints, boolean invert) {

        initLogger();
        this.numberFftPoints = numberFftPoints;
        this.isNumberFftPointsSet = (numberFftPoints != -1);
        this.invert = invert;
    }

    public DiscreteFourierTransform() {
    }

    /*
     * (non-Javadoc)
     *
     * @see
     * edu.cmu.sphinx.util.props.Configurable#newProperties(edu.cmu.sphinx.util.props.PropertySheet)
     */
    ActionListener hisTimerHandler = new ActionListener() {

        @Override
        public void actionPerformed(ActionEvent e) {
        }
    };

    @Override
    public void newProperties(PropertySheet ps) throws PropertyException {
        super.newProperties(ps);
        logger = ps.getLogger();
        numberFftPoints = ps.getInt(PROP_NUMBER_FFT_POINTS);
        isNumberFftPointsSet = (numberFftPoints != -1);
        invert = ps.getBoolean(PROP_INVERT);
    }


    /*
     * (non-Javadoc) @see
     * edu.cmu.sphinx.frontend.DataProcessor#initialize(edu.cmu.sphinx.frontend.CommonConfig)
     */
    @Override
    public void initialize() {
        super.initialize();
        if (isNumberFftPointsSet) {
            initializeFFT();
        }
    }

    /**
     * Initialize all the data structures necessary for computing FFT.
     */
    private void initializeFFT() {
        /**
         * Number of points in the FFT. By default, the value is 512, which
         * means that we compute 512 values around a circle in the complex
         * plane. Complex conjugate pairs will yield the same power, therefore
         * the power produced by indices 256 through 511 are symmetrical with
         * the ones between 1 and 254. Therefore, we need only return values
         * between 0 and 255.
         */
        computeLogBase2(numberFftPoints);
        createWeightFft(numberFftPoints, invert);
        initComplexArrays();
        weightFftTimesFrom2 = new Complex();
        tempComplex = new Complex();
    }

    /**
     * Initialize all the Complex arrays that will be necessary for FFT.
     */
    private void initComplexArrays() {

        inputFrame = new Complex[numberFftPoints];
        from = new Complex[numberFftPoints];
        to = new Complex[numberFftPoints];

        for (int i = 0; i < numberFftPoints; i++) {
            inputFrame[i] = new Complex();
            from[i] = new Complex();
            to[i] = new Complex();
        }
    }

    /**
     * Process data, creating the power spectrum from an input frame.
     *
     * @param input the input frame
     * @return a DoubleData that is the power spectrum of the input frame
     * @throws java.lang.IllegalArgumentException
     *
     */
    private DoubleData process(DoubleData input)
            throws IllegalArgumentException {

        /**
         * Create complex input sequence equivalent to the real input sequence.
         * If the number of points is less than the window size, we incur in
         * aliasing. If it's greater, we pad the input sequence with zeros.
         */
        double[] in = input.getValues();

        if (numberFftPoints < in.length) {
            int i = 0;
            for (; i < numberFftPoints; i++) {
                inputFrame[i].set(in[i], 0.0f);
            }
            for (; i < in.length; i++) {
                tempComplex.set(in[i], 0.0f);
                inputFrame[i % numberFftPoints].addComplex(inputFrame[i % numberFftPoints], tempComplex);
            }
        } else {
            int i = 0;
            for (; i < in.length; i++) {
                inputFrame[i].set(in[i], 0.0f);
            }
            for (; i < numberFftPoints; i++) {
                inputFrame[i].reset();
            }
        }

        /**
         * Create output sequence.
         */
        double[] outputSpectrum = new double[(numberFftPoints >> 1) + 1];

        /**
         * Start Fast Fourier Transform recursion
         */
        recurseFft(inputFrame, outputSpectrum, numberFftPoints, invert);

        /**
         * Return the power spectrum
         */
        DoubleData output = new DoubleData(outputSpectrum, input.getSampleRate(),
                input.getCollectTime(),
                input.getFirstSampleNumber());

        return output;
    }

    /**
     * Make sure the number of points in the FFT is a power of 2 by computing
     * its log base 2 and checking for remainders.
     *
     * @param numberFftPoints number of points in the FFT
     * @throws java.lang.IllegalArgumentException
     *
     */
    private void computeLogBase2(int numberFftPoints)
            throws IllegalArgumentException {
        this.logBase2NumberFftPoints = 0;
        for (int k = numberFftPoints; k > 1;
                k >>= 1, this.logBase2NumberFftPoints++) {
            if (((k % 2) != 0) || (numberFftPoints < 0)) {
                throw new IllegalArgumentException("Not a power of 2: "
                        + numberFftPoints);
            }
        }
    }

    /**
     * Initializes the <b>weightFft[]</b> vector.
     * <p>
     * <b>weightFft[k] = w ^ k</b></p> where:
     * <p>
     * <b>w = exp(-2 * PI * i / N)</b></p>
     * <p>
     * <b>i</b> is a complex number such that <b>i * i = -1</b> and <b>N</b> is
     * the number of points in the FFT. Since <b>w</b> is complex, this is the
     * same as</p>
     * <p>
     * <b>Re(weightFft[k]) = cos ( -2 * PI * k / N)</b></p>
     * <p>
     * <b>Im(weightFft[k]) = sin ( -2 * PI * k / N)</b></p>
     *
     * @param numberFftPoints number of points in the FFT
     * @param invert whether it's direct (false) or inverse (true) FFT
     */
    private void createWeightFft(int numberFftPoints, boolean invert) {
        /**
         * weightFFT will have numberFftPoints/2 complex elements.
         */
        weightFft = new Complex[numberFftPoints >> 1];

        /**
         * For the inverse FFT, w = 2 * PI / numberFftPoints;
         */
        double w = -2 * Math.PI / numberFftPoints;
        if (invert) {
            w = -w;
        }

        for (int k = 0; k < (numberFftPoints >> 1); k++) {
            weightFft[k] = new Complex(Math.cos(w * k), Math.sin(w * k));
        }
    }

    /**
     * Reads the next DoubleData object, which is a data frame from which we'll
     * compute the power spectrum. Signal objects just pass through unmodified.
     *
     * @return the next available power spectrum DoubleData object, or null if
     * no Spectrum object is available
     * @throws DataProcessingException if there is a processing error
     */
    @Override
    public Data getData() throws DataProcessingException {

        Data input = getPredecessor().getData();

        getTimer().start();

        if ((input != null) && (input instanceof DoubleData)) {
            DoubleData data = (DoubleData) input;
            if (!isNumberFftPointsSet) {
                /*
                 * If numberFftPoints is not set by the user, figure out the
                 * numberFftPoints and initialize the data structures
                 * appropriately.
                 */
                if (numberDataPoints != data.getValues().length) {
                    numberDataPoints = data.getValues().length;
                    numberFftPoints = getNumberFftPoints(numberDataPoints);
                    initializeFFT();
                }
            } else {
                /*
                 * Warn if the user-set numberFftPoints is not ideal.
                 */
                if (numberDataPoints != data.getValues().length) {
                    numberDataPoints = data.getValues().length;
                    int idealFftPoints = getNumberFftPoints(numberDataPoints);
                    if (idealFftPoints != numberFftPoints) {
                        logger.warning("User set numberFftPoints ("
                                + numberFftPoints + ") is not ideal ("
                                + idealFftPoints + ')');
                    }
                }
            }

            input = process(data);
            //*************** grab the output of FFT by cclo / every 0.01 sec FFTNo double frequency data ********************
            DoubleData output = (DoubleData) input;
            double cc[] = output.getValues();
            voice_Process(cc);
            //getVoid2(cc);

        }

        // At this point - or in the call immediatelly preceding
        // this -, we should have created a cepstrum frame with
        // whatever data came last, even if we had less than
        // window size of data.
        getTimer().stop();

        return input;
    }

    /**
     * Returns the ideal number of FFT points given the number of samples. The
     * ideal number of FFT points is the closest power of 2 that is equal to or
     * larger than the number of samples in the incoming window.
     *
     * @param numberSamples the number of samples in the incoming window
     * @return the closest power of 2 that is equal to or larger than the number
     * of samples in the incoming window
     */
    private static int getNumberFftPoints(int numberSamples) {
        int fftPoints = 1;

        while (fftPoints < numberSamples) {
            fftPoints <<= 1;
            if (fftPoints < 1) {
                throw new Error("Invalid # of FFT points: " + fftPoints);
            }
        }
        return fftPoints;
    }

    /**
     * Establish the recursion. The FFT computation will be computed by as a
     * recursion. Each stage in the butterfly will be fully computed during
     * recursion. In fact, we use the mechanism of recursion only because it's
     * the simplest way of switching the "input" and "output" vectors. The
     * output of a stage is the input to the next stage. The butterfly computes
     * elements in place, but we still need to switch the vectors. We could copy
     * it (not very efficient...) or, in C, switch the pointers. We can avoid
     * the pointers by using recursion.
     *
     * @param input input sequence
     * @param output output sequence
     * @param numberFftPoints number of points in the FFT
     * @param invert whether it's direct (false) or inverse (true) FFT
     */
    private void recurseFft(Complex[] input,
            double[] output,
            int numberFftPoints,
            boolean invert) {

        double divisor;

        /**
         * The direct and inverse FFT are essentially the same algorithm, except
         * for two difference: a scaling factor of "numberFftPoints" and the
         * signal of the exponent in the weightFft vectors, defined in the
         * method <code>createWeightFft</code>.
         */
        if (!invert) {
            divisor = 1.0;
        } else {
            divisor = (double) numberFftPoints;
        }

        /**
         * Initialize the "from" and "to" variables.
         */
        for (int i = 0; i < numberFftPoints; i++) {
            to[i].reset();
            from[i].scaleComplex(input[i], divisor);
        }

        /**
         * Repeat the recursion log2(numberFftPoints) times, i.e., we have
         * log2(numberFftPoints) butterfly stages.
         */
        butterflyStage(from, to, numberFftPoints, numberFftPoints >> 1);

        /**
         * Compute energy ("float") for each frequency point from the fft
         * ("complex")
         */
        if ((this.logBase2NumberFftPoints & 1) == 0) {
            for (int i = 0; i <= (numberFftPoints >> 1); i++) {
                output[i] = from[i].squaredMagnitudeComplex();
            }
        } else {
            for (int i = 0; i <= (numberFftPoints >> 1); i++) {
                output[i] = to[i].squaredMagnitudeComplex();
            }
        }
    }

    /**
     * Compute one stage in the FFT butterfly. The name "butterfly" appears
     * because this method computes elements in pairs, and a flowgraph of the
     * computation (output "0" comes from input "0" and "1" and output "1" comes
     * from input "0" and "1") resembles a butterfly.
     * <p/>
     * We repeat <code>butterflyStage</code> for <b>log_2(numberFftPoints)</b>
     * stages, by calling the recursion with the argument
     * <code>currentDistance</code> divided by 2 at each call, and checking if
     * it's still > 0.
     *
     * @param from the input sequence at each stage
     * @param to the output sequence
     * @param numberFftPoints the total number of points
     * @param currentDistance the "distance" between elements in the butterfly
     */
    private void butterflyStage(Complex[] from,
            Complex[] to,
            int numberFftPoints,
            int currentDistance) {
        int ndx1From;
        int ndx2From;
        int ndx1To;
        int ndx2To;
        int ndxWeightFft;

        if (currentDistance > 0) {

            int twiceCurrentDistance = 2 * currentDistance;

            for (int s = 0; s < currentDistance; s++) {
                ndx1From = s;
                ndx2From = s + currentDistance;
                ndx1To = s;
                ndx2To = s + (numberFftPoints >> 1);
                ndxWeightFft = 0;
                while (ndxWeightFft < (numberFftPoints >> 1)) {
                    /**
                     * <b>weightFftTimesFrom2 = weightFft[k] </b> <b>
                     * *from[ndx2From]</b>
                     */
                    weightFftTimesFrom2.multiplyComplex(weightFft[ndxWeightFft], from[ndx2From]);
                    /**
                     * <b>to[ndx1To] = from[ndx1From] </b> <b> +
                     * weightFftTimesFrom2</b>
                     */
                    to[ndx1To].addComplex(from[ndx1From], weightFftTimesFrom2);
                    /**
                     * <b>to[ndx2To] = from[ndx1From] </b> <b> -
                     * weightFftTimesFrom2</b>
                     */
                    to[ndx2To].subtractComplex(from[ndx1From], weightFftTimesFrom2);
                    ndx1From += twiceCurrentDistance;
                    ndx2From += twiceCurrentDistance;
                    ndx1To += currentDistance;
                    ndx2To += currentDistance;
                    ndxWeightFft += currentDistance;
                }
            }

            /**
             * This call'd better be the last call in this block, so when it
             * returns we go straight into the return line below.
             *
             * We switch the <i>to</i> and <i>from</i> variables, the total
             * number of points remains the same, and the <i>currentDistance</i>
             * is divided by 2.
             */
            butterflyStage(to, from, numberFftPoints, (currentDistance >> 1));
        }
    }
    //**************************************************************************
    Main pMain;
    double shortVec[] = new double[FFTNo];
    double featureFreq[] = new double[FFTNo];
    int iter5 = 0;
    int iter500 = 0;
    boolean silent = false;
    double SPEC_RATIO = 1.1;
    double DecayRate = 0.996;
    double peakAvg = 0.0;
    double specSum = 0.0, avgSpecSum = 0.09, avgSpecMag = 100.0, minSpecSum = Double.MAX_VALUE;
    int count = 0;
    int pkNo = 5;
    boolean stable = false;

    /*public void getBaby(double voice[]) {
       
        int peakIdx[] = new int[pkNo];
        double peakValue[] = new double[pkNo];
        boolean isPeak[] = new boolean[FFTNo];

        specSum = 0.0;

        for (int i = 0; i < FFTNo; i++) {
            isPeak[i] = true;
        }

        double ratio;
        for (int i = 0; i < FFTNo; i++) {
            shortVec[i] = shortVec[i] * 0.95 + voice[i] * 0.05; // short pattern
            specSum += shortVec[i];
        }
        if (specSum < minSpecSum) {
            minSpecSum = specSum;
        }
        avgSpecMag = specSum / (double) FFTNo;

        for (int i = 0; i < FFTNo; i++) {
            featureFreq[i] = Math.log10(shortVec[i]);
            // featureFreq[i] = shortVec[i];
        }
        pMain.freqFr.updateSpec(featureFreq);

        peakIdx[0] = -1;
        peakValue[0] = Double.MIN_VALUE;

        int low = 1, up;
        int cut = 5;
        int firstPeak = -1;
        boolean isFirstPeak = true;
        int leftOff = 5, rightOff = 5;
        for (int i = 0; i < FFTNo; i++) {
            if (i < cut) {
                isPeak[i] = false;
                continue;
            }
            if (isFirstPeak) {
                low = (i < cut ? cut : low);
                up = i + i - 3;

                if (up > FFTNo - 1) {
                    up = FFTNo - 1;
                }
            } else {
                low = i - leftOff;
                up = i + rightOff;
                if (up > FFTNo - 1) {
                    up = FFTNo - 1;
                }
            }

            for (int j = low; j <= up; j++) {
                if (featureFreq[i] < featureFreq[j]) {
                    isPeak[i] = false;
                    break;
                }
            }

            if (isPeak[i]) {
                if (isFirstPeak) {
                    leftOff = i - 3;
                    rightOff = i - 3;
                    isFirstPeak = false;
                }
                if (featureFreq[i] > peakValue[0]) {
                    peakIdx[0] = i;
                    peakValue[0] = featureFreq[i];
                }
            }
        }

        pMain.freqFr.updateSpec(featureFreq);
        peakAvg = peakAvg * 0.996 + peakValue[0] * 0.004;
        avgSpecSum = avgSpecSum * DecayRate + specSum * (1.0 - DecayRate);
        avgSpecMag = avgSpecSum / (double) FFTNo;
        if (count == 0) {
            // System.out.print("\nPeak Avg: " + peakAvg);
            // System.out.print("\nSpecSum Avg: " + avgSpecSum);
        }
        count = (++count) % 1000;
        int val = 0;
        if (specSum > minSpecSum * SPEC_RATIO) { // && specSum > 1.001 * avgSpecSum) { // && specSum > 9020.0) {
            silent = false;

            for (int i = 0; i < FFTNo; i++) {
                if (isPeak[i]) { // // && shortVec[i] > avgSpecMag * 1.0) {
                    val = 1;
                    // System.out.print(" " + i);
                } else {
                    isPeak[i] = false;
                    val = 0;
                }
                // pMain.specFr.wChart2.updateSeries(i, val);
            }
            pMain.scorer.matchLevel(isPeak);

        } else {
            if (!silent) {
                // System.out.print("\nS ");
                pMain.scorer.resetLevel();
                silent = true;
                pMain.scorer.resetLevel();
            }
//            stable = true;
//            DecayRate = 0.996;
            pMain.freqFr.updateSpec(featureFreq);
        }
        if (pMain.scorer.tFileState == STATE.RECORDING) {
//                if (++iter500 % 50 == 0) {
//                    System.out.printf(".");
//                    iter500 = 1;
//                    for (int i = 0; i < FFTNo; i++) {
//                        pMain.scorer.addData(i, 0.0);
//                    }
//                } else {
//                    return;
//                }
        } else if (pMain.scorer.latState == STATE.MATCH) {
//            if (++iter500 % 500 == 0) {
//                IncNode iNode = new IncNode();
//                iter500 = 1;
//                for (int i = 0; i < FFTNo; i++) {
//                    iNode.add(i, featureFreq[i]);
//                }
//                // pMain.scorer.addMatchInput(iNode);
//            } else {
//                return;
//            }
        }
    }*/
    public void setShortDiffAvg(double shortDiffAvg_) {
    }

    public void setMagThresh(double magThresh_) {
        SPEC_RATIO = magThresh_;
        // System.out.println("\nMag_Thresh: " + SPEC_RATIO);
    }

    public void setAED(Main aed_) {
        pMain = aed_;
    }

    /*public void getVoid(double voice[]) {//voice[1024]輸入

        specSum = 0.0;
        for (int i = 0; i < FFTNo; i++) {
            shortVec[i] = shortVec[i] * 0.95 + voice[i] * 0.05; // short pattern
            specSum += shortVec[i];
        }
        if (specSum < minSpecSum) {
            minSpecSum = specSum;
        }
        avgSpecMag = specSum / (double) FFTNo;
        for (int i = 0; i < FFTNo; i++) {
            featureFreq[i] = Math.log10(shortVec[i]);
        }
        pMain.freqFr.updateSpec(featureFreq);
        //-------------------------------------------------------------------------//上面套用老師寫的
        double tempFreq[] = new double[FFTNo];//暫存頻率
        double characterFreqMax[] = new double[128];//最大頻率
        double characterFreq[] = new double[128];//特徵頻率
        System.arraycopy(featureFreq, 0, tempFreq, 0, featureFreq.length);//把特徵陣列(老師)複製到暫存陣列裡
        int j = 0;
        for (int i = 0; i < FFTNo; i += 8) {
            characterFreq[j] = (tempFreq[i] + tempFreq[i + 1] + tempFreq[i + 2] + tempFreq[i + 3]
                    + tempFreq[i + 1] + tempFreq[i + 4] + tempFreq[i + 5] + tempFreq[i + 6]) / 8;//將暫存陣列平均存到特徵陣列(我)裡 以8個為一單位
            j++;
        }
        System.arraycopy(characterFreq, 0, characterFreqMax, 0, characterFreq.length);//將特徵陣列(我)複製到最大特徵陣列(我)裡
        Arrays.sort(characterFreqMax);//排序找出最大
        double maxFreq = characterFreqMax[127];//將最大值儲存到maxFreq
        System.out.println(maxFreq);
        int characterIndex = 0;
        for (int i = 0; i < 128; i++) {//找出此maxFreq的index值
            if (characterFreq[i] == maxFreq) {
                characterIndex = i;
                break;
            }
        }
        char chPrint[] = new char[128]; //儲存星號陣列

        for (int i = 0; i < 128; i++) {//畫出星號所在位置
            if (i != characterIndex) {
                chPrint[i] = ' ';
            } else {
                chPrint[i] = '*';
            }
        }
        String temp = Arrays.toString(chPrint);

        // testframe putdata = new testframe();
        pMain.tFrame.putdata(temp);
        System.out.println(Arrays.toString(chPrint));
    }*/
//    public void getVoid2(double voice[]) {
//
//        int peakIdx[] = new int[pkNo];
//        double peakValue[] = new double[pkNo];
//        boolean isPeak[] = new boolean[FFTNo];
//
//        specSum = 0.0;
//
//        for (int i = 0; i < FFTNo; i++) {
//            isPeak[i] = true;
//        }
//
//        double ratio;
//        for (int i = 0; i < FFTNo; i++) {
//            shortVec[i] = shortVec[i] * 0.5 + voice[i] * 0.5; // short pattern
//            specSum += shortVec[i];
//        }
//        if (specSum < minSpecSum) {
//            minSpecSum = specSum;
//        }
//        avgSpecMag = specSum / (double) FFTNo;
//
//        for (int i = 0; i < FFTNo; i++) {
//            featureFreq[i] = Math.log10(shortVec[i]);
//            // featureFreq[i] = shortVec[i];
//        }
//        pMain.freqFr.updateSpec(featureFreq);
//
//        peakIdx[0] = -1;
//        peakValue[0] = Double.MIN_VALUE;
//
//        int low = 1, up;
//        int cut = 5;
//        int firstPeak = -1;
//        boolean isFirstPeak = true;
//        int leftOff = 5, rightOff = 5;
//        for (int i = 0; i < FFTNo; i++) {
//            if (i < cut) {
//                isPeak[i] = false;
//                continue;
//            }
//            if (isFirstPeak) {
//                low = (i < cut ? cut : low);
//                up = i + i - 3;
//
//                if (up > FFTNo - 1) {
//                    up = FFTNo - 1;
//                }
//            } else {
//                low = i - leftOff;
//                up = i + rightOff;
//                if (up > FFTNo - 1) {
//                    up = FFTNo - 1;
//                }
//            }
//
//            for (int j = low; j <= up; j++) {
//                if (featureFreq[i] < featureFreq[j]) {
//                    isPeak[i] = false;
//                    break;
//                }
//            }
//
//            if (isPeak[i]) {
//                if (isFirstPeak) {
//                    leftOff = i - 3;
//                    rightOff = i - 3;
//                    isFirstPeak = false;
//                }
//                if (featureFreq[i] > peakValue[0]) {
//                    peakIdx[0] = i;
//                    peakValue[0] = featureFreq[i];
//                }
//            }
//        }
//
//        pMain.freqFr.updateSpec(featureFreq);
//        peakAvg = peakAvg * 0.96 + peakValue[0] * 0.04;
//        avgSpecSum = avgSpecSum * DecayRate + specSum * (1.0 - DecayRate);
//        avgSpecMag = avgSpecSum / (double) FFTNo;
//        if (count == 0) {
//            // System.out.print("\nPeak Avg: " + peakAvg);
//            // System.out.print("\nSpecSum Avg: " + avgSpecSum);
//        }
//        count = (++count) % 1000;
//        int val = 0;
//        if (specSum > minSpecSum * SPEC_RATIO) { // && specSum > 1.001 * avgSpecSum) { // && specSum > 9020.0) {
//            silent = false;
//
//            for (int i = 0; i < FFTNo; i++) {
//                if (isPeak[i]) { // // && shortVec[i] > avgSpecMag * 1.0) {
//                    val = 1;
//                    // System.out.print(" " + i);
//                } else {
//                    isPeak[i] = false;
//                    val = 0;
//                }
//                // pMain.specFr.wChart2.updateSeries(i, val);
//            }
//            pMain.scorer.matchLevel(isPeak);
//
//        } else {
//            if (!silent) {
//                // System.out.print("\nS ");
//                pMain.scorer.resetLevel();
//                silent = true;
//                pMain.scorer.resetLevel();
//            }
////            stable = true;
////            DecayRate = 0.996;
//            pMain.freqFr.updateSpec(featureFreq);
//        }
//        //----------------------------------------------------------------------
//        //getPeak1(featureFreq);
//        //getPeak2(featureFreq);
//        getPeak(featureFreq);
//        //----------------------------------------------------------------------
//        double max = 0;
//        double min = 99999;
//        for (int i = 0; i < FFTNo; i++) {//找出最大最小值
//            if (max < featureFreq[i]) {
//                max = featureFreq[i];
//            }
//            if (min > featureFreq[i]) {
//                min = featureFreq[i];
//            }
//        }
//        double encode = max - min; //取最大值最小值的區間
//        int encodeFreq[] = new int[FFTNo];
//        for (int i = 0; i < FFTNo; i++) {
//            encodeFreq[i] = (int) ((featureFreq[i] - min) * (255 / encode)); //對每個頻率進行編碼(0~255)
//        }
//
//        // System.out.println("pudata");
//        pMain.tFrame.putdata(encodeFreq);
//        //----------------------------------------------------------------------
//
//    }
//    public void getPeak1(double featureFreq[]) {//可取到重點波峰，資料處理速度快
//        Queue<Integer> isPeak = new LinkedList<>();
//        Queue<Double> isPeakValue = new LinkedList<>();
//        int peakNo = 0;
//        while ((peakNo + 4) <= featureFreq.length) {
//            double peak[] = new double[8];
//            System.arraycopy(featureFreq, peakNo, peak, 0, 8);//區間取樣，將區間複製到peak陣列裡(來源陣列，來源起始索引，目的陣列，目的起始索引，複製長度)
//            double max = 0;
//            int maxIndex = 0;
//            for (int i = 0; i < 8; i++) {//找出最大值
//                if (max < peak[i]) {
//                    max = peak[i];
//                    maxIndex = i + peakNo; //存儲最大值的索引
//                }
//            }
//            if (max != 0 && (maxIndex == peakNo || maxIndex == peakNo + 8)) {//當若最大值不是在區間取樣的邊線時，則為波峰
//                break;
//            } else {
//                if (isPeak.contains(maxIndex)) {
//                    break;
//                } else {
//                    isPeak.offer(maxIndex);//將波峰放入佇列中
//                    isPeakValue.offer(featureFreq[maxIndex]);//將波峰值放入佇列中
//                }
//            }
//            peakNo += 4;
//        }
//        System.out.println(isPeak.toString());
//        //System.out.println(isPeakValue.toString());
//        //----------------------------------------------------------------------
//        Queue<Double> realPeak = new LinkedList<>();
//        double d = 21.533203125;
//        for (int index : isPeak) {
//            int i = 1;
//            while (index * i <= 1024) {//確認是否有梵音
//                Integer sanskrit = (index * i); //梵音索引為倍數增長
//                /*if (index < 30 && i == 2) { //前面的區段，取到二個梵音就列入
//                    realPeak.offer(index * d);
//                } else if (index > 30 && i == 3) { //後面的區段，若成功找到三個梵音一樣為波峰，就將它列入
//                    realPeak.offer(index * d);
//                }*/
//                if (i == 2) {
//                    realPeak.offer(index * d);
//                }
//                if (featureFreq[sanskrit] > featureFreq[sanskrit - 1] && featureFreq[sanskrit] > featureFreq[sanskrit + 1]) {
//                    i++;
//                } else {
//                    break;
//                }
//                /*if (isPeak.contains(sanskritlow)||isPeak.contains(sanskritup)) {
//                    i++;
//                } else {
//                    break;
//                }*/
//            }
//        }
//
//        System.out.println(realPeak.toString());
//        //----------------------------------------------------------------------
//        String sanskritArr[][] = { //將音階對照表列出，從0開始到5
//            {"16.35", "32.70", "65.41", "130.81", "261.63", "523.25", "C"},
//            {"17.32", "34.65", "69.30", "138.59", "277.18", "554.37", "C♯/D♭"},
//            {"18.35", "36.71", "73.42", "146.83", "293.66", "587.33", "D"},
//            {"19.45", "38.89", "77.78", "155.56", "311.13", "622.25", "D♯/E♭"},
//            {"20.60", "41.20", "82.41", "164.81", "329.63", "659.26", "E"},
//            {"21.83", "43.65", "87.31", "174.61", "349.23", "698.46", "F"},
//            {"23.12", "46.25", "92.50", "185.00", "369.99", "739.99", "F♯/G♭"},
//            {"24.50", "49.00", "98.00", "196.00", "392.00", "783.99", "G"},
//            {"25.96", "51.91", "103.83", "207.65", "415.30", "830.61", "G♯/A♭"},
//            {"27.50", "55.00", "110.00", "220.00", "440.00", "880.00", "A"},
//            {"29.14", "58.27", "116.54", "233.08", "466.16", "932.33", "A♯/B♭"},
//            {"30.87", "61.74", "123.47", "246.94", "493.88", "987.77", "B"}
//        };
//        while (!realPeak.isEmpty()) {
//            Double temp = realPeak.poll();
//            for (String arr[] : sanskritArr) { //逐列判斷是否有在這些區間
//                for (int i = 0; i < arr.length; i++) {
//                    if (i == 6) {
//                        break;
//                    }
//                    if (Math.floor(temp - i * 2) == Math.floor(Double.parseDouble(arr[i]))
//                            || (Math.floor(temp - i * 2) < Math.floor(Double.parseDouble(arr[i]))
//                            && Math.floor(Double.parseDouble(arr[i])) < Math.floor(temp + i * 2))) {//當i越大，容許誤差也越大
//                        System.out.println(arr[6] + "[" + i + "]");
//                    }
//                }
//            }
//        }
//    }
//    public void getPeak2(double featureFreq[]) { //取前面200個波峰
//        Queue<Integer> isPeak = new LinkedList<>();
//        double peak[] = new double[500];
//        System.arraycopy(featureFreq, 0, peak, 0, 500);//區間取樣，將區間複製到peak陣列裡(來源陣列，來源起始索引，目的陣列，目的起始索引，複製長度)
//        for (int i = 1; i < peak.length - 1; i++) {
//            if (peak[i] >= 6 && i >= 5) {
//                if (peak[i] > peak[i - 1] && peak[i] > peak[i + 1]) { //若當前的頻率比前後頻率都高，就把它視為波峰 
//                    isPeak.offer(i);
//                    //isPeakValue.offer(featureFreq[i]);
//                }
//            }
//        }
//        System.out.println(isPeak.toString());
//        //----------------------------------------------------------------------
//        String sanskritArr[][] = { //將音階對照表列出，從0開始到5
//            {"1.614", "3.193", "6.387", "12.774", "25.549", "51.098", "C"},
//            {"1.691", "3.383", "6.767", "13.534", "27.068", "54.137", "C♯/D♭"},
//            {"1.791", "3.584", "7.169", "14.338", "28.677", "57.356", "D"},
//            {"1.899", "3.797", "7.595", "15.191", "30.383", "60.766", "D♯/E♭"},
//            {"2.011", "4.023", "8.047", "16.094", "32.190", "64.380", "E"},
//            {"2.131", "4.262", "8.526", "17.051", "34.104", "68.208", "F"},
//            {"2.257", "4.516", "9.033", "18.066", "36.131", "72.264", "F♯/G♭"},
//            {"2.392", "4.785", "9.570", "19.140", "38.281", "76.561", "G"},
//            {"2.535", "5.069", "10.139", "20.278", "40.556", "81.114", "G♯/A♭"},
//            {"2.685", "5.371", "10.742", "21.484", "42.968", "85.937", "A"},
//            {"2.845", "5.690", "11.380", "22.761", "45.523", "91.047", "A♯/B♭"},
//            {"3.014", "6.029", "12.057", "24.115", "48.230", "96.461", "B"}
//        };
//        Queue<String> Peak = new LinkedList<>();
//        for (String arr[] : sanskritArr) {
//            for (int i = 0; i < arr.length; i++) {
//                if (i == 6) {
//                    break;
//                }
//                for (int j = 1; j <= 10; j++) {
//                    int count = 0;
//                    Integer check = (int) (Double.parseDouble(arr[i]) * j);
//                    if (isPeak.contains(check) || isPeak.contains(check + 1) || isPeak.contains(check - 1)) {
//                        count++;
//                    }
//                    if (count > 3) {
//                        System.out.println(arr[6] + "[" + i + "]");
//                        Peak.offer(arr[6] + "[" + i + "]");
//                        break;
//                    }
//                }
//            }
//        }
//        System.out.println(Peak.toString());
//    } 
    public void voice_Process(double voice[]) {
        for (int i = 0; i < FFTNo; i++) {
            shortVec[i] = shortVec[i] * 0.95 + voice[i] * 0.05; // short pattern
        }
        for (int i = 0; i < FFTNo; i++) {
            featureFreq[i] = Math.log10(shortVec[i]);
            // featureFreq[i] = shortVec[i];
        }
        pMain.freqFr.updateSpec(featureFreq);
        //----------------------------------------------------------------------
        getPeak(featureFreq);
        //----------------------------------------------------------------------
    }

    public void getPeak(double featureFreq[]) { //取前面200個波峰
        LinkedList<Integer> isPeak = new LinkedList<>();
        double peak[] = new double[500];
        System.arraycopy(featureFreq, 0, peak, 0, 500);//區間取樣，將區間複製到peak陣列裡(來源陣列，來源起始索引，目的陣列，目的起始索引，複製長度)
        for (int i = 1; i < peak.length - 1; i++) {
            if (peak[i] >= 7 && i >= 5) {
                if (peak[i] > peak[i - 1] && peak[i] > peak[i + 1]) { //若當前的頻率比前後頻率都高，就把它視為波峰 
                    isPeak.offer(i);
                    //isPeakValue.offer(featureFreq[i]);
                }
            }
        }
//        System.out.println("Peak:" + isPeak.toString());
//        Integer[] temparr= isPeak.toArray(new Integer[isPeak.size()]);
        if (isPeak.size() >= 5) {
            int temparr[] = new int[isPeak.size()];
            for (int i = 0; i < isPeak.size(); i++) {
                temparr[i] = isPeak.get(i);
            }
            //voice_Store_User(temparr); //使用者輸入資料
            //voice_Store_DB(temparr); //將歌曲存至資料庫
        }

        voice_Compare(isPeak);
        //----------------------------------------------------------------------

//        LinkedList<String> Peak = new LinkedList<>();
//        for (String arr[] : sanskritArr) {
//            int PeakCount = 0;
//            for (int i = 0; i < arr.length; i++) {
//                if (i == 15) {
//                    break;
//                }
//                if (PeakCount > 10) {
//                    Peak.offer(arr[15]);
//                    break;
//                }
//                if (isPeak.contains(Integer.parseInt(arr[i]))) {
//                    PeakCount++;
//                }
//            }
//        }
//        System.out.println(Peak.toString());
    }

    LinkedList<int[]> store = new LinkedList<>(); //存放即將放入資料庫的資料
    LinkedList<int[]> userInput = new LinkedList<>(); //user輸入
    LinkedList<String> db = new LinkedList<>(); //用來存放從DB拿取到的資料
    LinkedList<String> dbcopy = new LinkedList<>();
    LinkedList<int[]> compare = new LinkedList<>();  //轉換完成的整數波峰資料
    LinkedList<String> test = new LinkedList<>();

    public void voice_Store_DB(int[] peak) {//用來儲存音樂特徵
        boolean opener = false;
        if (store.size() < 300) { //限制歌曲的儲存長度為300個波峰陣列
            store.offer(peak);
            if (store.size() == 300) {//若轉換完成，開啟存取DB開關
                opener = true;
            }
        } else {
            System.out.println("Music input time is too long!");
        }
        if (opener == true) { //若存取開關開啟
            //JSONArray jsonarray = JSONArray.fromObject(store);
            //pMain.con.insert(store);//將資料寫入DB
            opener = false;
        }
    }

    public void voice_Store_User(int[] peak) {//用來儲存音樂特徵
        boolean opener = false;
        if (userInput.size() < 300) { //限制歌曲的儲存長度為300個波峰陣列
            userInput.offer(peak);
        } else {
            System.out.println("Music input time is too long!");
        }
    }

    public void voice_Take() {
        boolean opener = false;
        if (db.isEmpty()) {//若db為空，開啟存取DB開關
            opener = true;
        }
        if (opener == true) { //若存取開關開啟
            opener = false;
            //db = pMain.con.takeout(); //從DB取資料
            //dbcopy = pMain.con.takeout(); //複製來轉換成整數陣列
            get_TransferData(); //轉換一筆資料庫的資料供比對
        }
    }

    public void get_TransferData() { //只會轉換一筆
        String x = dbcopy.pop();
        String sub = x.substring(1, x.length() - 2);
        String rex = "],";
        String temS[] = sub.split(rex);
        for (int i = 0; i < temS.length; i++) { //將需要的陣列取出並刪除多餘字元
            temS[i] = temS[i].substring(1);
            String temStoI[] = temS[i].split(",");
            int temI[] = new int[temStoI.length];
            for (int j = 0; j < temStoI.length; j++) {
                temI[j] = Integer.parseInt(temStoI[j]);
            }
            compare.offer(temI);
        }
    }
    LinkedList<Integer> Tone = new LinkedList<>();
    LinkedList<Integer> phrase = new LinkedList<>();//樂劇

    public void voice_Compare(LinkedList isPeak) {
        String sanskritArr[][] = { //將音階對照表列出，從0開始到5
            //C[3]
            {"6", "12", "18", "24", "30", "36", "42", "49", "54", "61", "67", "73", "79", "85", "91", "97", "103", "109", "115", "121", "127", "133", "139", "146", "152", "158", "164", "170", "176", "182", "188", "194", "200", "206", "212", "218", "224", "231", "237", "243", "249", "255", "261", "267", "273", "279", "285", "291", "297", "303", "309", "315", "322", "328", "334", "340", "346", "352", "358", "364", "370", "376", "382", "388", "394", "401", "407", "412", "419", "425", "431", "437", "443", "449", "455", "461", "467", "473", "479", "485", "491", "497"},
            {"6", "13", "19", "26", "32", "39", "45", "52", "58", "64", "70", "77", "84", "90", "97", "103", "110", "116", "123", "129", "136", "142", "149", "155", "161", "168", "174", "181", "187", "193", "200", "206", "212", "219", "226", "232", "238", "245", "252", "258", "264", "271", "278", "284", "290", "296", "302", "309", "315", "322", "328", "335", "342", "348", "355", "361", "368", "374", "380", "387", "393", "400", "406", "412", "418", "425", "432", "438", "444", "451", "458", "464", "470", "477", "483", "490", "496"},//Do up
            {"7", "14", "21", "27", "33", "41", "48", "55", "62", "69", "76", "82", "89", "96", "102", "109", "116", "123", "130", "137", "144", "151", "158", "165", "172", "178", "185", "192", "199", "206", "213", "219", "226", "232", "239", "246", "253", "260", "267", "274", "280", "287", "294", "301", "308", "315", "322", "329", "336", "342", "349", "355", "363", "370", "377", "383", "390", "397", "404", "411", "418", "425", "431", "438", "445", "452", "459", "465", "472", "479", "485", "492", "499"},//Re
            {"7", "14", "22", "29", "36", "43", "51", "58", "65", "72", "80", "87", "94", "101", "109", "116", "123", "130", "138", "145", "152", "159", "167", "174", "181", "188", "196", "203", "210", "217", "225", "232", "239", "246", "254", "261", "268", "275", "283", "290", "297", "305", "312", "319", "326", "333", "341", "348", "355", "363", "370", "377", "384", "392", "399", "406", "414", "421", "428", "435", "443", "450", "456", "463", "470", "477", "485", "492"},//Re up
            {"8", "15", "23", "31", "38", "46", "54", "61", "69", "76", "84", "92", "99", "107", "115", "122", "130", "138", "145", "153", "160", "176", "183", "191", "199", "206", "214", "222", "229", "237", "244", "252", "259", "267", "275", "283", "291", "298", "306", "314", "321", "329", "337", "343", "351", "359", "367", "374", "382", "390", "397", "405", "412", "420", "428", "436", "443", "451", "459", "466", "474", "482", "490", "497"},//Mi
            {"8", "16", "24", "32", "40", "48", "56", "65", "73", "81", "89", "97", "105", "113", "121", "129", "136", "145", "153", "160", "169", "177", "185", "193", "202", "210", "218", "226", "234", "242", "250", "258", "266", "274", "282", "290", "298", "306", "313", "322", "330", "338", "347", "354", "362", "371", "379", "387", "395", "403", "411", "418", "426", "434", "442", "450", "457", "465", "473", "482", "490", "498"},//Fa
            {"9", "17", "26", "34", "43", "51", "60", "68", "77", "86", "94", "103", "111", "120", "129", "137", "146", "154", "163", "171", "180", "189", "197", "206", "214", "223", "231", "240", "249", "257", "266", "274", "283", "291", "300", "309", "317", "325", "334", "343", "351", "360", "368", "377", "385", "393", "403", "411", "420", "428", "437", "446", "454", "462", "471", "480", "489", "498"},//Fa up
            {"9", "18", "27", "36", "45", "54", "63", "72", "81", "91", "100", "109", "118", "126", "135", "144", "153", "162", "171", "180", "189", "198", "207", "216", "225", "234", "243", "252", "261", "271", "280", "284", "288", "298", "307", "316", "324", "333", "343", "351", "361", "370", "379", "388", "396", "405", "414", "424", "433", "442", "452", "461", "477", "486", "496"},//So
            {"10", "19", "29", "38", "48", "58", "67", "77", "86", "96", "106", "115", "125", "134", "144", "153", "163", "172", "182", "192", "201", "211", "220", "229", "240", "249", "259", "268", "278", "288", "297", "307", "316", "325", "335", "345", "355", "363", "373", "383", "393", "402", "412", "422", "430", "441", "450", "460", "470", "479", "489"},//So up
            {"10", "20", "31", "41", "51", "61", "71", "82", "92", "102", "112", "122", "133", "143", "153", "163", "173", "184", "194", "204", "214", "224", "235", "245", "255", "265", "275", "285", "296", "306", "316", "326", "336", "347", "357", "367", "377", "388", "398", "408", "418", "428", "438", "448", "458", "468", "479", "489"},//La
            {"11", "22", "32", "43", "54", "65", "75", "86", "97", "108", "118", "129", "140", "151", "162", "172", "183", "194", "205", "216", "226", "237", "248", "259", "269", "280", "291", "302", "312", "323", "334", "345", "355", "367", "377", "388", "399", "410", "420", "431", "442", "453", "463", "475", "485", "496"},//La up
            {"11", "23", "34", "46", "57", "69", "80", "92", "103", "115", "126", "138", "149", "161", "172", "183", "195", "206", "218", "229", "241", "252", "263", "275", "286", "298", "309", "321", "332", "344", "355", "366", "378", "389", "401", "412", "424", "435", "447", "458", "469", "481", "493"},//Si
            //C[4]
            {"12", "24", "36", "49", "61", "73", "85", "97", "109", "121", "133", "146", "158", "170", "182", "194", "206", "218", "231", "243", "255", "267", "279", "291", "303", "315", "328", "340", "352", "364", "376", "388", "401", "412", "425", "437", "449", "461", "473", "485", "497"},
            {"13", "26", "39", "52", "64", "77", "90", "103", "116", "129", "142", "155", "168", "181", "193", "206", "219", "232", "245", "258", "271", "284", "296", "309", "322", "335", "348", "361", "374", "387", "400", "412", "425", "438", "451", "464", "477", "490"},
            {"14", "27", "41", "55", "69", "82", "96", "109", "123", "137", "151", "165", "178", "192", "206", "219", "232", "246", "260", "274", "287", "301", "315", "329", "342", "355", "370", "383", "397", "411", "425", "438", "452", "465", "479", "492"},
            {"14", "29", "43", "58", "72", "87", "101", "116", "130", "145", "159", "174", "188", "203", "217", "232", "246", "261", "275", "290", "305", "319", "333", "348", "363", "377", "392", "406", "421", "435", "450", "463", "477", "492"},
            {"15", "31", "46", "61", "76", "92", "107", "122", "138", "153", "176", "191", "206", "222", "237", "252", "267", "283", "298", "314", "329", "343", "359", "374", "390", "405", "420", "436", "451", "466", "482", "497"},
            {"16", "32", "48", "65", "81", "97", "113", "129", "145", "160", "177", "193", "210", "226", "242", "258", "274", "290", "306", "322", "338", "354", "371", "387", "403", "418", "434", "450", "465", "482", "498"},
            {"17", "34", "51", "68", "86", "103", "120", "137", "154", "171", "189", "206", "223", "240", "257", "274", "291", "309", "325", "343", "360", "377", "393", "411", "428", "446", "462", "480", "498"},
            {"18", "36", "54", "72", "91", "109", "126", "144", "162", "180", "198", "216", "234", "252", "271", "284", "298", "316", "333", "351", "370", "388", "405", "424", "442", "461", "486"},
            {"19", "38", "58", "77", "96", "115", "134", "153", "172", "192", "211", "229", "249", "268", "288", "307", "325", "345", "363", "383", "402", "422", "441", "460", "479"},
            {"20", "41", "61", "82", "102", "122", "143", "163", "184", "204", "224", "245", "265", "285", "306", "326", "347", "367", "388", "408", "428", "448", "468", "489"},
            {"22", "43", "65", "86", "108", "129", "151", "172", "194", "216", "237", "259", "280", "302", "323", "345", "367", "388", "410", "431", "453", "475", "496"},
            {"23", "46", "69", "92", "115", "138", "161", "183", "206", "229", "252", "275", "298", "321", "344", "366", "389", "412", "435", "458", "481"},
            //C[5]
            {"24", "49", "73", "97", "121", "146", "170", "194", "218", "243", "267", "291", "315", "340", "364", "388", "412", "437", "461", "485"},
            {"26", "52", "77", "103", "129", "155", "181", "206", "232", "258", "284", "309", "335", "361", "387", "412", "438", "464", "490"},
            {"27", "55", "82", "109", "137", "165", "192", "219", "246", "274", "301", "329", "355", "383", "411", "438", "465", "492"},
            {"29", "58", "87", "116", "145", "174", "203", "232", "261", "290", "319", "348", "377", "406", "435", "463", "492"},
            {"31", "61", "92", "122", "153", "191", "222", "252", "283", "314", "343", "374", "405", "436", "466", "497"},
            {"32", "65", "97", "129", "160", "193", "226", "258", "290", "322", "354", "387", "418", "450", "482"},
            {"34", "68", "103", "137", "171", "206", "240", "274", "309", "343", "377", "411", "446", "480"},
            {"36", "72", "109", "144", "180", "216", "252", "284", "316", "351", "388", "424", "461"},
            {"38", "77", "115", "153", "192", "229", "268", "307", "345", "383", "422", "460"},
            {"41", "82", "122", "163", "204", "245", "285", "326", "367", "408", "448", "489"},
            {"43", "86", "129", "172", "216", "259", "302", "345", "388", "431", "475"},
            {"46", "92", "138", "183", "229", "275", "321", "366", "412", "458"},
            //C[6]
            {"49", "97", "146", "194", "243", "291", "340", "388", "437", "485"}
        };

        String MajorTone[] = {"null", "C", "C#", "D", "D♯/E♭", "E", "F", "F♯/G♭", "G", "G♯/A♭", "A", "A♯/B♭", "B"};// null的index為0，音階位置會全部加一
        int ToneTmp_Encoding[] = new int[sanskritArr.length + 1];//Tmp

        int MajorTone_index = 0;

        //走訪最外層的音階和內層每個音階的頻率
        //ToneTmp_Encoding先做找出單筆最高的音調
        for (int i = 0; i < sanskritArr.length; i++) {
            for (int j = 0; j < sanskritArr[i].length; j++) {
                if (isPeak.contains(Integer.parseInt(sanskritArr[i][j]))) {
                    ToneTmp_Encoding[i + 1]++;
                }
            }
            if (ToneTmp_Encoding[i + 1] > ToneTmp_Encoding[MajorTone_index]) {
                MajorTone_index = i + 1;
            }
        }

        int FindMax = 0;
        if(Tone.size()>=10){ //先判斷資料是否
            System.out.println("Peak:"+isPeak.toString());
            while(!Tone.isEmpty()){
                ToneTmp_Encoding[Tone.pop()]++;
            }
            System.out.println("ToneTmp_Encoding"+Arrays.toString(ToneTmp_Encoding));
            for(int i=0;i<ToneTmp_Encoding.length;i++){
                if(ToneTmp_Encoding[FindMax]<=ToneTmp_Encoding[i]){
                    FindMax = i;
                }
            }
            if(phrase.isEmpty()){
                phrase.offer(FindMax);
            } else {
                if(phrase.getLast()==FindMax){
                    System.out.println("Same Data");
                } else {
                    phrase.pop();
                    phrase.offer(FindMax);
                    System.out.println("Tone:"+FindMax);
                }
            }
            
        } else {
            if(isPeak.isEmpty()){
                Tone.offer(0);
            } else {
                Tone.offer(MajorTone_index);
            }
        }

    }
}
